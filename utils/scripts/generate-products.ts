// TODO: This should uh... probably be written in Rust

import * as https from "https";
import * as path from "path";
import { promises as fs } from "fs"

const PREAMBLE = `// NOTE: THIS FILE IS AUTOMATICALLY GENERATED

#[derive(Clone, Debug)]
pub struct ProductInfo {
	pub name: &'static str,
	pub color: bool,
	pub chain: bool,
	pub matrix: bool,
	pub infrared: bool,
	pub multizone: bool,
	pub temperature_range: Option<(u16, u16)>,
}

/// Look up info about what a LIFX product supports.
///
/// You can get the vendor and product IDs from a bulb by receiving a [Message::StateVersion] message
///
/// Data is taken from https://github.com/LIFX/products/blob/master/products.json
pub fn get_product_info(vendor: u32, product: u32) -> Option<&'static ProductInfo> {
	match (vendor, product) {
`;
const POSTFIX = `
	}
}
`;
const SOURCE_URL = "https://raw.githubusercontent.com/LIFX/products/master/products.json";

const FEATURE_KEYS = ["color", "chain", "matrix", "infrared", "multizone"];

type FeatureKey = typeof FEATURE_KEYS[number];

interface IProductInfo {
	pid: number;
	name: string;
	features: {
		temperature_range?: [number, number];
	} & Record<FeatureKey, boolean>;
}

(async function () {
	let content = PREAMBLE;
	let products = await fetchInfo().catch(handle) as IProductInfo[]

	products.forEach(p => {
		content += [
			`		(1, ${p.pid}) => Some(&ProductInfo {\n`,
			`			name: "${p.name}",\n`,
		].join("")

		FEATURE_KEYS.forEach(key => {
			content += `			${key}: ${p.features[key]},\n`
		})

		if (p.features.temperature_range) {
			const [low, high] = p.features.temperature_range
			content += `			temperature_range: Some((${low}, ${high})),\n`
		} else {
			content += `			temperature_range: None,\n`
		}

		content += `		}),\n`
	})

	content += `		(_, _) => None,`
	content += POSTFIX

	let fpath = path.resolve(process.cwd(), "../../lifx-core/src/product.rs")
	await fs.writeFile(fpath, content).catch(handle)
})()

async function fetchInfo(): Promise<IProductInfo[]> {
	let buffer = await new Promise<string>((resolve, reject) => {
		let req = https.get(SOURCE_URL, res => {
			let data = ""

			res.on("data", chunk => data += chunk)
			res.on("end", () => resolve(data))
			res.on("error", reject)
		})

		req.on("error", reject)
	})

	return JSON.parse(buffer)[0].products
}

function handle(err: Error): void {
	console.log(err)
	process.exit(1)
}
